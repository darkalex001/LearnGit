---
title: "C语言基础"
subtitle: 'C语言基础'
author: "Kevin"
header-style: text
tags:
  - C语言
---

# 1 C语言概述

## 1.1 什么是C语言

一提到语言这个词语，自然会想到的是像英语、汉语等这样的自然语言，因为它是人和人交换信息不可缺少的工具。

而今天计算机遍布了我们生活的每一个角落，除了人和人的相互交流之外，我们必须和计算机角落。

用什么的什么样的方式和计算机做最直接的交流呢？人们自然想到的是最古老也最方便的方式——语言，而C语言就是人和计算机交流的一种语言。

语言是用来交流沟通的。有一方说，有另一方听，必须有两方参与，这是语言最重要的功能：

> - 说的一方传递信息，听的一方接收信息；
> - 说的一方下达指令，听的一方遵循命令做事情。

语言是人和人交流，C语言是人和机器交流。只是，人可以不听另外一个人，但是，计算机是无条件服从。

语言有独特的语法规则和定义，双方必须遵循这些规则和定义才能实现真正的交流。



### 1.2.3 程序和指令

- 指令是对计算机进行程序控制的最小单位。
- 所有的指令的集合称为计算机的指令系统。
- 程序是为完成一项特定任务而用某种语言编写的一组指令序列。



## 1.3 语言发展历程

### 1.3.1 机器语言

计算机的大脑或者说心脏就是CPU，它控制着整个计算机的运作。每种CPU，都有自己的指令系统。这个指令系统，就是该CPU的机器语言。

机器语言是一组由0和1系列组成的指令码，这些指令码，是CPU制作厂商规定出来的，然后发布出来，请程序员遵守。

要让计算机干活，就得用机器语言(二级制数)去命令它。这样的命令，不是一条两条，而是上百条。而且不同型号的计算机其机器语言是不相通的，按着一种计算机的机器指令编制的程序，不能在另一种计算机上执行。



### 1.3.2汇编语言和编译器

机器语言编程是不是很令人烦恼呢，终于出现了汇编语言，就是一些标识符取代0与1。一门人类可以比较轻松认识的编程语言。

只是这门语言计算机并不认识，所以人类还不能用这门语言命令计算机做事情。这正如如何才能让中国人说的话美国人明白呢？——翻译！

所以，有一类专门的程序，既认识机器语言，又认识汇编语言，也就是编译器，将标识符换成0与1，知道怎么把汇编语言翻译成机器语言。



### 1.3.3高级语言

汇编语言和机器语言都是面向机器的，机器不同，语言也不同。既然有办法让汇编语言翻译成机器语言，难道就不能把其他更人性化的语言翻译成机器语言？

1954年，Fortran语言出现了，其后相继出现了其他的类似语言。这批语言，使程序员摆脱了计算机硬件的限制，把主要精力放在了程序设计上，不在关注低层的计算机硬件。这类语言，称为高级语言。

同样的，高级语言要被计算机执行，也需要一个翻译程序将其翻译成机器语言，这就是编译程序，简称编译器。

这类高级语言解决问题的方法是分析出解决问题所需要的步骤，把程序看作是数据被加工的过程。基于这类方法的程序设计语言成为面向过程的语言。C语言就是这种面向过程的程序设计语言。



### 1.3.4语言的层次

![image-20190924135239228](assets/image-20190924135239228.png)



### 1.3.5语言进化史

![image-20190924135204504](assets/image-20190924135204504.png)

![image-20190924135309228](assets/image-20190924135309228.png)



## 1.4 为什么要学习C语言

### 1.4.1 C语言特点

- 优点
    - 代码量小
    - 执行速度快
    - 功能强大
    - 编程自由

- 缺点
    - 写代码实现周期长
    - 可移植性较差
    - 过于自由，经验不足易出错
    - 对平台库依赖较多



### 1.4.2学习C语言理由

![image-20190924135457336](assets/image-20190924135457336.png)



### 1.4.3 C语言应用领域

C语言的应用极其广泛，从网站后台，到底层操作系统，从多媒体应用到大型网络游戏，均可使用C语言来开发：

- l C语言可以写网站后台程序
- l C语言可以专门针对某个主题写出功能强大的程序库
- l C语言可以写出大型游戏的引擎
- l C语言可以写出另一个语言来
- l C语言可以写操作系统和驱动程序，并且只能用C语言编写
- l 任何设备只要配置了微处理器，就都支持C语言。从微波炉到手机，都是由C语言技术来推动的

![image-20190924135612619](assets/image-20190924135612619.png)



### 1.4.4 C语言的简洁

> C语言仅有32个关键字，9种控制语句，34种运算符，却能完成无数的功能

![image-20190924135643610](assets/image-20190924135643610.png)

![image-20190924135654324](assets/image-20190924135654324.png)

![image-20190924135704621](assets/image-20190924135704621.png)



### 1.4.5 学习C语言的常见困惑

![image-20190924135721531](assets/image-20190924135721531.png)



## 1.5第一个C语言程序：HelloWorld

### 1.5.1编写C语言代码：hello.c

```c
#include <stdio.h>

int main()
{
	//这是第一个C语言代码
	printf("hello world\n");

	return 0;
}
```

C语言的源代码文件是一个普通的文本文件，但扩展名必须是.c。



### 1.5.2通过gcc编译C代码

#### `gcc编译器`介绍

编辑器(如vi、记事本)是指我用它来写程序的（编辑代码），而我们写的代码语句，电脑是不懂的，我们需要把它转成电脑能懂的语句，编译器就是这样的转化工具。就是说，我们用编辑器编写程序，由编译器编译后才可以运行！

编译器是将易于编写、阅读和维护的高级计算机语言翻译为计算机能解读、运行的低级机器语言的程序。

`gcc`（GNUCompiler Collection，GNU 编译器套件），是由 GNU 开发的编程语言编译器。gcc原本作为GNU操作系统的官方编译器，现已被大多数类Unix操作系统（如Linux、BSD、MacOS X等）采纳为标准的编译器，gcc同样适用于微软的Windows。

`gcc`最初用于编译C语言，随着项目的发展gcc已经成为了能够编译C、C++、Java、Ada、fortran、ObjectC、Object C++、Go语言的编译器大家族。

编译命令格式：

```bash
gcc [-option1] ... <filename>
g++ [-option1] ... <filename>
```

- l 命令、选项和源文件之间使用空格分隔
- l 一行命令中可以有零个、一个或多个选项
- l 文件名可以包含文件的绝对路径，也可以使用相对路径
- l 如果命令中不包含输出可执行文件的文件名，可执行文件的文件名会自动生成一个默认名，Linux平台为a.out，Windows平台为a.exe



#### gcc、g++编译常用选项说明：

| **选项** | **含义**                   |
| -------- | -------------------------- |
| -o file  | 指定生成的输出文件名为file |
| -E       | 只进行预处理               |
| -S(大写) | 只进行预处理和编译         |
| -c(小写) | 只进行预处理、编译和汇编   |



#### Linux平台下编译代码

![image-20190924140102161](assets/image-20190924140102161.png)

- l gcc warning的意思是警告，是有问题，但不影响编译
- l error是错误，如果遇到error，那么就不能编译了



#### Windows平台下gcc环境配置

windows命令行界面下，默认是没有gcc编译器，我们需要配置一下环境。由于我们安装了Qt，Qt是一个集成开发环境，内部集成gcc编译器，配置一下环境变量即可使用gcc。



##### a)进入Qt安装目录：

![image-20190924140216406](assets/image-20190924140216406.png)



##### b)拷贝gcc所在的路径（不同安装目录有所差异）

`C:\Qt\Qt5.5.0\Tools\mingw492_32\bin`

![image-20190924140303365](assets/image-20190924140303365.png)



##### c) 设置windows环境变量

计算机（右击）－> 属性：

![image-20190924140336849](assets/image-20190924140336849.png)

![image-20190924140345338](assets/image-20190924140345338.png)

![image-20190924140355352](assets/image-20190924140355352.png)

如果是win7，双击Path后，把拷贝的路径追加到后面，路径之间需要英文”**;** ”分隔：

![image-20190924140411449](assets/image-20190924140411449.png)

如果是win10，界面做得友好一下，新建添加路径即可：

![image-20190924140425217](assets/image-20190924140425217.png)

##### d)测试gcc命令：

![image-20190924140444419](assets/image-20190924140444419.png)

![image-20190924140500120](assets/image-20190924140500120.png)



##### 4) Windows平台下编译代码

![image-20190924140548306](assets/image-20190924140548306.png)

![image-20190924140604558](assets/image-20190924140604558.png)



##### 5) 注意事项

Linux编译后的可执行程序只能在Linux运行，Windows编译后的程序只能在Windows下运行。

64位的Linux编译后的程序只能在64位Linux下运行，32位Linux编译后的程序只能在32位的Linux运行。

64位的Windows编译后的程序只能在64位Windows下运行，32位Windows编译后的程序可以在64位的Windows运行。



### 1.5.3代码分析

##### 1) include头文件包含

- l `#include`的意思是头文件包含，`#include <stdio.h>`代表包含`stdio.h`这个头文件
- l 使用C语言库函数需要提前包含库函数对应的头文件，如这里使用了`printf()`函数，需要包含`stdio.h`头文件
- l 可以通过`man 3 printf`查看`printf`所需的头文件

 

`#include< >` 与 `#include ""`的区别：

- l `< >` 表示系统直接按系统指定的目录检索
- l `""` 表示系统先在 "" 指定的路径(没写路径代表当前路径)查找头文件，如果找不到，再按系统指定的目录检索



![image-20190924140803675](assets/image-20190924140803675.png)



##### 2) main函数

- l 一个完整的C语言程序，是由一个、且只能有一个main()函数(又称主函数，必须有)和若干个其他函数结合而成（可选）。
- l main函数是C语言程序的入口，程序是从main函数开始执行。



##### 3) `{}` 括号，程序体和代码块

- `{}`叫代码块，一个代码块内部可以有一条或者多条语句
- C语言每句可执行代码都是`;`分号结尾
- 所有的`#`开头的行，都代表`预编译指令`，预编译指令行**结尾**是**没有分号**的
- 所有的可执行语句必须是在代码块里面



##### 4) 注释

- `//`叫行注释，注释的内容编译器是忽略的，注释主要的作用是在代码中加一些说明和解释，这样有利于代码的阅读
- `/**/`叫块注释
- 块注释是C语言标准的注释方法
- 行注释是从C++语言借鉴过来的



##### 5) printf函数

- `printf`是C语言库函数，功能是向标准输出设备输出一个字符串
- `printf(“hello world\n”);`//`\n`的意思是回车换行



##### 6) return语句

- `return`代表函数执行完毕，返回return代表函数的终止
- 如果`main`定义的时候前面是int，那么return后面就需要写一个整数；如果main定义的时候前面是`void`，那么return后面什么也不需要写
- 在`main`函数中`return 0`代表程序执行成功，`return -1`代表程序执行失败
- `int main()`和`void main()`在C语言中是一样的，但`C++`只接受`int main`这种定义方式



## 1.6 system函数

### 1.6.1 system函数的使用

```
#include <stdlib.h>
int system(const char *command);
功能：在已经运行的程序中执行另外一个外部程序
参数：外部可执行程序名字
返回值：
成功：不同系统返回值不一样
失败：通常是 - 1
```

示例代码：

```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
	//system("calc"); //windows平台
	system("ls"); //Linux平台, 需要头文件#include <stdlib.h>

	return 0;
}
```



### 1.6.2 system返回值不同系统结果不一样

C语言所有的库函数调用，只能保证语法是一致的，但不能保证执行结果是一致的，同样的库函数在不同的操作系统下执行结果可能是一样的，也可能是不一样的。 

在学习Linux发展史时，我们得知Linux的发展离不开POSIX标准，只要符合这个标准的函数，在不同的系统下执行的结果就可以一致。

Unix和linux很多库函数都是支持POSIX的，但Windows支持的比较差。

如果将Unix代码移植到Linux一般代价很小，如果把Windows代码移植到Unix或者Linux就比较麻烦。



### 1.6.3 Qt图形界面调用system

![image-20190924141451343](assets/image-20190924141451343.png)

```c
void Widget::on_pushButton_clicked()
{
    //system("calc"); //需要头文件：#include <stdlib.h>
    WinExec("calc", SW_NORMAL); //需要头文件：#include <windows.h>
}

void Widget::on_pushButton_2_clicked()
{
    system("notepad");
}

void Widget::on_pushButton_3_clicked()
{
    system("mmc");
}
```



### 1.6.4MFC图形界面调用system

![image-20190924141533538](assets/image-20190924141533538.png)

```c
void CvssystemDlg::OnBnClickedButton1()
{
	// TODO:  在此添加控件通知处理程序代码
	//WinExec("calc", SW_NORMAL); 需要头文件：#include <windows.h>
	system("calc"); //需要头文件：#include <stdlib.h>
}

void CvssystemDlg::OnBnClickedButton2()
{
	// TODO:  在此添加控件通知处理程序代码
	//WinExec("notepad", SW_NORMAL);
	system("notepad");
}
```



## 1.7C语言编译过程

### 1.7.1 C程序编译步骤

C代码编译成可执行程序经过4步：

1）预处理：宏定义展开、头文件展开、条件编译等，同时将代码中的注释删除，这里并不会检查语法

2）编译：检查语法，将预处理后文件编译生成汇编文件

3）汇编：将汇编文件生成目标文件(二进制文件)

4）链接：C语言写的程序是需要依赖各种库的，所以编译之后还需要把库链接到最终的可执行程序中去

![image-20190924141617646](assets/image-20190924141617646.png)



### 1.7.2 gcc编译过程

##### 1) 分步编译

```
预处理：gcc -E hello.c -o hello.i
编  译：gcc -S hello.i -o hello.s
汇  编：gcc -c hello.s -o hello.o
链  接：gcc    hello.o -o hello_elf
```

| **选项** | **含义**                    |
| -------- | --------------------------- |
| -E       | 只进行预处理                |
| -S(大写) | 只进行预处理和编译          |
| -c(小写) | 只进行预处理、编译和汇编    |
| -o file  | 指定生成的输出文件名为 file |

| **文件后缀** | **含义**             |
| ------------ | -------------------- |
| .c           | C 语言文件           |
| .i           | 预处理后的C 语言文件 |
| .s           | 编译后的汇编文件     |
| .o           | 编译后的目标文件     |

![image-20190924141710254](assets/image-20190924141710254.png)



##### 2) 一步编译

`gcc hello.c -o demo`（还是经过：预处理、编译、汇编、链接的过程）：

![image-20190924141732934](assets/image-20190924141732934.png)



### 1.7.3查找程序所依赖的动态库

1）Linux平台下，ldd(“l”为字母) 可执行程序：

![image-20190924141802304](assets/image-20190924141802304.png)

2）Windows平台下，需要相应软件(Depends.exe)：

![image-20190924141825914](assets/image-20190924141825914.png)

![image-20190924141837111](assets/image-20190924141837111.png)



## 1.8 CPU内部结构与寄存器(了解)

### 1.8.1 64位和32位系统区别

- 寄存器是CPU内部最基本的存储单元
- CPU对外是通过总线(地址、控制、数据)来和外部设备交互的，总线的宽度是8位，同时CPU的寄存器也是8位，那么这个CPU就叫8位CPU
- 如果总线是32位，寄存器也是32位的，那么这个CPU就是32位CPU
- 有一种CPU内部的寄存器是32位的，但总线是16位，准32位CPU
- 所有的64位CPU兼容32位的指令，32位要兼容16位的指令，所以在64位的CPU上是可以识别32位的指令
- 在64位的CPU构架上运行了64位的软件操作系统，那么这个系统是64位
- 在64位的CPU构架上，运行了32位的软件操作系统，那么这个系统就是32位
- 64位的软件不能运行在32位的CPU之上



### 1.8.2寄存器名字(了解)

| 8位  | 16位 | 32位 | 64位 |
| ---- | ---- | ---- | ---- |
| A    | AX   | EAX  | RAX  |
| B    | BX   | EBX  | RBX  |
| C    | CX   | ECX  | RCX  |
| D    | DX   | EDX  | RDX  |



### 1.8.3寄存器、缓存、内存三者关系

按与CPU远近来分，离得最近的是寄存器，然后缓存(CPU缓存)，最后内存。 

CPU计算时，先预先把要用的数据从硬盘读到内存，然后再把即将要用的数据读到寄存器。于是CPU<--->寄存器<--->内存，这就是它们之间的信息交换。

那为什么有缓存呢？因为如果老是操作内存中的同一址地的数据，就会影响速度。于是就在寄存器与内存之间设置一个缓存。

因为从缓存提取的速度远高于内存。当然缓存的价格肯定远远高于内存，不然的话，机器里就没有内存的存在。

由此可以看出，从远近来看：CPU〈---〉寄存器〈---> 缓存<---> 内存。



## 1.9汇编语言

## 1.9.1VS中C语言嵌套汇编代码(了解)

```c
#include <stdio.h>

int main()
{
	//定义整型变量a, b, c
	int a;
	int b;
	int c;

	__asm
	{
		mov a, 3	//3的值放在a对应内存的位置
		mov b, 4	//4的值放在a对应内存的位置
		mov eax, a	//把a内存的值放在eax寄存器
		add eax, b	//eax和b相加，结果放在eax
		mov c, eax	//eax的值放在c中
	}
	
	printf("%d\n",  c);//把c的值输出

	return 0;//成功完成
```



### 1.9.2 VS反汇编

```c
#include <stdio.h>

int main()
{
	//定义整型变量a, b, c
	int a;
	int b;
	int c;

	a = 3;
	b = 4;
	c = a + b;
	
	printf("%d\n",  c);//把c的值输出

	return 0;//成功完成
}
```

##### 1)设置断点F9

![image-20190924142125368](assets/image-20190924142125368.png)

##### 2)选择反汇编按钮

![image-20190924142143011](assets/image-20190924142143011.png)

3)根据汇编代码分析程序

![image-20190924142159627](assets/image-20190924142159627.png)



## 1.10 集成开发环境IDE

集成开发环境（IDE，Integrated Development Environment ）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。



### 1.10.1Qt Creator

Qt Creator是跨平台的Qt IDE，Qt Creator 是Qt 被Nokia 收购后推出的一款新的轻量级集成开发环境（IDE）。此IDE 能够跨平台运行，支持的系统包括Linux（32 位及64 位）、Mac OS X 以及Windows。根据官方描述，Qt Creator 的设计目标是使开发人员能够利用Qt 这个应用程序框架更加快速及轻易的完成开发任务。

| **快捷键**  | **含义**                   |
| ----------- | -------------------------- |
| Ctrl + i    | 自动格式化代码             |
| Ctrl + /    | 注释/取消注释              |
| Alt + Enter | 自动完成类函数定义         |
| F4          | .h 文件和对应.cpp 文件切换 |
| F9          | 设置断点                   |
| F5          | 调试运行                   |
| Ctrl + r    | 编译，但不调试运行         |
| Ctrl + b    | 编译，不运行               |
| F10         | next调试                   |
| F11         | step调试                   |



### 1.10.2Microsoft Visual Studio

Microsoft Visual Studio（简称VS）是美国微软公司的开发工具包系列产品。VS是一个基本完整的开发工具集，它包括了整个软件生命周期中所需要的大部分工具，如UML工具、代码管控工具、集成开发环境(IDE)等等,所写的目标代码适用于微软支持的所有平台。Visual Studio是目前最流行的Windows平台应用程序的集成开发环境。

##### 1) VS常用快捷键

| **快捷键**        | **含义**       |
| ----------------- | -------------- |
| Ctrl + k,Ctrl + f | 自动格式化代码 |
| Ctrl + k,Ctrl + c | 注释代码       |
| Ctrl + k,Ctrl + u | 取消注释代码   |
| F9                | 设置断点       |
| F5                | 调试运行       |
| Ctrl + F5         | 不调试运行     |
| Ctrl + Shift + b  | 编译，不运行   |
| F10               | next调试       |
| F11               | step调试       |

##### 2) VS2013的C4996错误

由于微软在VS2013中不建议再使用C的传统库函数scanf,strcpy,sprintf等，所以直接使用这些库函数会提示C4996错误：

![image-20190924142305162](assets/image-20190924142305162.png)

VS建议采用带_s的函数，如scanf_s、strcpy_s，但这些并不是标准C函数。

要想继续使用此函数，需要在源文件中添加以下指令就可以避免这个错误提示：

```
#define _CRT_SECURE_NO_WARNINGS     //这个宏定义最好要放到.c文件的第一行
#pragma warning(disable:4996)		//或者使用这个
```



# 2. 数据类型

## 2.1 常量与变量

### 2.1.1 关键字

![image-20190924142355759](assets/image-20190924142355759.png)



### 2.1.2数据类型

数据类型的作用：编译器预算对象（变量）分配的内存空间大小。

![image-20190924142421720](assets/image-20190924142421720.png)



### 2.1.3常量

常量：

- 在程序运行过程中，其值不能被改变的量
- 常量一般出现在表达式或赋值语句中

| 整型常量   | 100，200，-100，0    |
| ---------- | -------------------- |
| 实型常量   | 3.14 ，0.125，-3.123 |
| 字符型常量 | ‘a’,‘b’,‘1’,‘\n’     |
| 字符串常量 | “a”,“ab”，“12356”    |



### 2.1.4变量

1) 变量

##### 变量：

- 在程序运行过程中，其值可以改变
- 变量在使用前必须先定义，定义变量前必须有相应的数据类型

##### 标识符命名规则：

- 标识符不能是关键字
- 标识符只能由字母、数字、下划线组成
- 第一个字符必须为字母或下划线
- 标识符中字母区分大小写

##### 变量特点：

- 变量在编译时为其分配相应的内存空间
- 可以通过其名字和地址访问相应内存

![image-20190924142629863](assets/image-20190924142629863.png)

##### 2) 声明和定义区别

- 声明变量不需要建立存储空间，如：extern int a;
- 定义变量需要建立存储空间，如：int b;

```c
#include <stdio.h>

int main()
{
	//extern 关键字只做声明，不能做任何定义，后面还会学习，这里先了解
	//声明一个变量a，a在这里没有建立存储空间
	extern int a;
	a = 10;	//err, 没有空间，就不可以赋值

	int b = 10;	//定义一个变量b，b的类型为int，b赋值为10

	return 0;
}
```

从广义的角度来讲声明中包含着定义，即定义是声明的一个特例，所以并非所有的声明都是定义：

- `int b`它既是声明，同时又是定义
- 对于 `extern b`来讲它只是声明不是定义

 一般的情况下，把建立存储空间的声明称之为“定义”，而把不需要建立存储空间的声明称之为“声明”。



### 2.1.5使用示例

```c
#include <stdio.h>
#define MAX 10 //声明了一个常量，名字叫MAX，值是10，常量的值一旦初始化不可改

int main()
{
	int a;	//定义了一个变量，其类型为int，名字叫a

	const int b = 10; //定义一个const常量，名为叫b，值为10
	//b = 11; //err,常量的值不能改变

	//MAX = 100;	//err,常量的值不能改变

	a = MAX;//将abc的值设置为MAX的值
	a = 123;

	printf("%d\n", a); //打印变量a的值

	return 0;
}
```



## 2.2 进制

进制也就是进位制，是人们规定的一种进位方法。 对于任何一种进制—X进制，就表示某一位置上的数运算时是逢X进一位。 十进制是逢十进一，十六进制是逢十六进一，二进制就是逢二进一，以此类推，x进制就是逢x进位。

| **十进制** | **二进制** | **八进制** | **十六进制** |
| ---------- | ---------- | ---------- | ------------ |
| 0          | 0          | 0          | 0            |
| 1          | 1          | 1          | 1            |
| 2          | 10         | 2          | 2            |
| 3          | 11         | 3          | 3            |
| 4          | 100        | 4          | 4            |
| 5          | 101        | 5          | 5            |
| 6          | 110        | 6          | 6            |
| 7          | 111        | 7          | 7            |
| 8          | 1000       | 10         | 8            |
| 9          | 1001       | 11         | 9            |
| 10         | 1010       | 12         | A            |
| 11         | 1011       | 13         | B            |
| 12         | 1100       | 14         | C            |
| 13         | 1101       | 15         | D            |
| 14         | 1110       | 16         | E            |
| 15         | 1111       | 17         | F            |
| 16         | 10000      | 20         | 10           |



### 2.2.1 二进制

二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”。

当前的计算机系统使用的基本上是二进制系统，数据在计算机中主要是以补码的形式存储的。

| **术语**     | **含义**                                                     |
| ------------ | ------------------------------------------------------------ |
| bit(比特)    | 一个二进制代表一位，一个位只能表示0或1两种状态。数据传输是习惯以“位”（bit）为单位。 |
| Byte(字节)   | 一个字节为8个二进制，称为8位，计算机中存储的最小单位是字节。数据存储是习惯以“字节”（Byte）为单位。 |
| WORD(双字节) | 2个字节，16位                                                |
| DWORD        | 两个WORD，4个字节，32位                                      |
| 1b           | 1bit，1位                                                    |
| 1B           | 1Byte,1字节，8位                                             |
| 1k，1K       | 1024                                                         |
| 1M(1兆)      | 1024k, 1024*1024                                             |
| 1G           | 1024M                                                        |
| 1T           | 1024G                                                        |
| 1Kb(千位)    | 1024bit,1024位                                               |
| 1KB(千字节)  | 1024Byte，1024字节                                           |
| 1Mb(兆位)    | 1024Kb = 1024 * 1024bit                                      |
| 1MB(兆字节)  | 1024KB = 1024 * 1024Byte                                     |

十进制转化二进制的方法：用十进制数除以2，分别取余数和商数，商数为0的时候，将余数倒着数就是转化后的结果。

![image-20190924142905455](assets/image-20190924142905455.png)

十进制的小数转换成二进制：小数部分和2相乘，取整数，不足1取0，每次相乘都是小数部分，顺序看取整后的数就是转化后的结果。

![image-20190924142918567](assets/image-20190924142918567.png)



### 2.2.2八进制

八进制，Octal，缩写OCT或O，一种以8为基数的计数法，采用0，1，2，3，4，5，6，7八个数字，逢八进1。一些编程语言中常常以数字0开始表明该数字是八进制。

八进制的数和二进制数可以按位对应（八进制一位对应二进制三位），因此常应用在计算机语言中。

![image-20190924142945731](assets/image-20190924142945731.png)

十进制转化八进制的方法：

用十进制数除以8，分别取余数和商数，商数为0的时候，将余数倒着数就是转化后的结果。

![image-20190924142959160](assets/image-20190924142959160.png)



### 2.2.3十六进制

十六进制（英文名称：Hexadecimal），同我们日常生活中的表示法不一样，它由0-9，A-F组成，字母不区分大小写。与10进制的对应关系是：0-9对应0-9，A-F对应10-15。

十六进制的数和二进制数可以按位对应（十六进制一位对应二进制四位），因此常应用在计算机语言中。

![image-20190924143137503](assets/image-20190924143137503.png)

十进制转化十六进制的方法：

用十进制数除以16，分别取余数和商数，商数为0的时候，将余数倒着数就是转化后的结果。

![image-20190924143152215](assets/image-20190924143152215.png)



### 2.2.4C语言如何表示相应进制数

| 十进制   | 以正常数字1-9开头，如123  |
| -------- | ------------------------- |
| 八进制   | 以数字0开头，如0123       |
| 十六进制 | 以0x开头，如0x123         |
| 二进制   | C语言不能直接书写二进制数 |

```c
#include <stdio.h>

int main()
{
	int a = 123;		//十进制方式赋值
	int b = 0123;		//八进制方式赋值， 以数字0开头
	int c = 0xABC;	//十六进制方式赋值

	//如果在printf中输出一个十进制数那么用%d，八进制用%o，十六进制是%x
	printf("十进制：%d\n",a );
	printf("八进制：%o\n", b);	//%o,为字母o,不是数字
	printf("十六进制：%x\n", c);

	return 0;
}
```



## 2.3计算机内存数值存储方式

### 2.3.1 原码

一个数的原码(原始的二进制码)有如下特点：

- 最高位做为符号位，0表示正,为1表示负
- 其它数值部分就是数值本身绝对值的二进制数
- 负数的原码是在其绝对值的基础上，最高位变为1

下面数值以1字节的大小描述：

| **十进制数** | **原码**  |
| ------------ | --------- |
| +15          | 0000 1111 |
| -15          | 1000 1111 |
| +0           | 0000 0000 |
| -0           | 1000 0000 |

原码表示法简单易懂，与带符号数本身转换方便，只要符号还原即可，但当两个正数相减或不同符号数相加时，必须比较两个数哪个绝对值大，才能决定谁减谁，才能确定结果是正还是负，所以原码不便于加减运算。



### 2.3.2反码

- 对于正数，反码与原码相同
- 对于负数，符号位不变，其它部分取反(1变0,0变1)

| **十进制数** | **反码**  |
| ------------ | --------- |
| +15          | 0000 1111 |
| -15          | 1111 0000 |
| +0           | 0000 0000 |
| -0           | 1111 1111 |

反码运算也不方便，通常用来作为求补码的中间过渡。



### 2.3.3补码

**在计算机系统中，数值一律用补码来存储。**

补码特点：

- 对于正数，原码、反码、补码相同
- 对于负数，其补码为它的反码加1
- 补码符号位不动，其他位求反，最后整个数加1，得到原码

| **十进制数** | **补码**  |
| ------------ | --------- |
| +15          | 0000 1111 |
| -15          | 1111 0001 |
| +0           | 0000 0000 |
| -0           | 0000 0000 |

```c
#include <stdio.h>

int main()
{
	int  a = -15;

	printf("%x\n", a);
	//结果为 fffffff1
	//fffffff1对应的二进制：1111 1111 1111 1111 1111 1111 1111 0001
	//符号位不变，其它取反：1000 0000 0000 0000 0000 0000 0000 1110
	//上面加1：1000 0000 0000 0000 0000 0000 0000 1111  最高位1代表负数，就是-15

	return 0;
}
```



### 2.3.4补码的意义

示例1：用8位二进制数分别表示+0和-0

| **十进制数** | **原码**  |
| ------------ | --------- |
| +0           | 0000 0000 |
| -0           | 1000 0000 |

| **十进制数** | **反码**  |
| ------------ | --------- |
| +0           | 0000 0000 |
| -0           | 1111 1111 |

不管以原码方式存储，还是以反码方式存储，0也有两种表示形式。为什么同样一个0有两种不同的表示方法呢？

但是如果以补码方式存储，补码统一了零的编码：

| **十进制数** | **补码**                                              |
| ------------ | ----------------------------------------------------- |
| +0           | 0000 0000                                             |
| -0           | 10000 0000由于只用8位描述，最高位1丢弃，变为0000 0000 |

示例2：计算9-6的结果

以原码方式相加：

| **十进制数** | **原码**  |
| ------------ | --------- |
| 9            | 0000 1001 |
| -6           | 1000 0110 |

![image-20190924143514551](assets/image-20190924143514551.png)

结果为-15，不正确。

以补码方式相加：

| **十进制数** | **补码**  |
| ------------ | --------- |
| 9            | 0000 1001 |
| -6           | 1111 1010 |

![image-20190924143537018](assets/image-20190924143537018.png)

最高位的1溢出,剩余8位二进制表示的是3，正确。

**在计算机系统中，数值一律用补码来存储**，主要原因是：

- 统一了零的编码
- 将符号位和其它位统一处理
- 将减法运算转变为加法运算
- 两个用补码表示的数相加时，如果最高位(符号位)有进位，则进位被舍弃



## 2.4 sizeof关键字

- `sizeof`不是函数，所以不需要包含任何头文件，它的功能是计算一个数据类型的大小，单位为字节
- `sizeof`的返回值为`size_t`
- `size_t`类型在32位操作系统下是`unsigned int`，是一个无符号的整数

```c
#include <stdio.h>

int main()
{
	int a;
	int b = sizeof(a);//sizeof得到指定值占用内存的大小，单位：字节
	printf("b = %d\n", b);

	size_t c = sizeof(a);
	printf("c = %u\n", c);//用无符号数的方式输出c的值

	return 0;
}
```



## 2.5整型：int

### 2.5.1整型变量的定义和输出

| **打印格式** | **含义**                              |
| ------------ | ------------------------------------- |
| %d           | 输出一个有符号的10进制int类型         |
| %o(字母o)    | 输出8进制的int类型                    |
| %x           | 输出16进制的int类型，字母以小写输出   |
| %X           | 输出16进制的int类型，字母以大写写输出 |
| %u           | 输出一个10进制的无符号数              |

```c
#include <stdio.h>

int main()
{
	int a = 123;	//定义变量a，以10进制方式赋值为123
	int b = 0567;	//定义变量b，以8进制方式赋值为0567
	int c = 0xabc;	//定义变量c，以16进制方式赋值为0xabc

	printf("a = %d\n", a);
	printf("8进制：b = %o\n", b);
	printf("10进制：b = %d\n", b);
	printf("16进制：c = %x\n", c);
	printf("16进制：c = %X\n", c);
	printf("10进制：c = %d\n", c);

	unsigned int d = 0xffffffff; //定义无符号int变量d，以16进制方式赋值
	printf("有符号方式打印：d = %d\n", d);
	printf("无符号方式打印：d = %u\n", d);
	return 0;
}
```



### 2.5.2 整型变量的输入

```c
#include <stdio.h>

int main()
{
	int a;
	printf("请输入a的值：");

	//不要加“\n”
	scanf("%d", &a);

	printf("a = %d\n", a); //打印a的值

	return 0;
}
```



### 2.5.3 short、int、long、long long

| **数据类型**        | **占用空间**                                    |
| ------------------- | ----------------------------------------------- |
| short(短整型)       | 2字节                                           |
| int(整型)           | 4字节                                           |
| long(长整形)        | Windows为4字节，Linux为4字节(32位)，8字节(64位) |
| long long(长长整形) | 8字节                                           |

注意：

- 需要注意的是，整型数据在内存中占的字节数与所选择的操作系统有关。虽然C 语言标准中没有明确规定整型数据的长度，但long 类型整数的长度不能短于int 类型，short 类型整数的长度不能短于int 类型。
- 当一个小的数据类型赋值给一个大的数据类型，不会出错，因为编译器会自动转化。但当一个大的类型赋值给一个小的数据类型，那么就可能丢失高位。

| **整型常量** | **所需类型**               |
| ------------ | -------------------------- |
| 10           | 代表int类型                |
| 10l, 10L     | 代表long类型               |
| 10ll, 10LL   | 代表long long类型          |
| 10u, 10U     | 代表unsigned int类型       |
| 10ul, 10UL   | 代表unsigned long类型      |
| 10ull, 10ULL | 代表unsigned long long类型 |

| **打印格式** | **含义**                   |
| ------------ | -------------------------- |
| %hd          | 输出short类型              |
| %d           | 输出int类型                |
| %l           | 输出long类型               |
| %ll          | 输出long long类型          |
| %hu          | 输出unsigned short类型     |
| %u           | 输出unsigned int类型       |
| %lu          | 输出unsigned long类型      |
| %llu         | 输出unsigned long long类型 |

```c
#include <stdio.h>

int main()
{
	short a = 10;
	int b = 10;
	long c = 10l; //或者10L
	long long d = 10ll; //或者10LL

	printf("sizeof(a) = %u\n", sizeof(a));
	printf("sizeof(b) = %u\n", sizeof(b));
	printf("sizeof(c) = %u\n", sizeof(c));
	printf("sizeof(c) = %u\n", sizeof(d));

	printf("short a = %hd\n", a);
	printf("int b = %d\n", b);
	printf("long c = %ld\n", c);
	printf("long long d = %lld\n", d);

	unsigned short a2 = 20u;
	unsigned int b2 = 20u;
	unsigned long c2= 20ul; 
	unsigned long long d2 = 20ull; 

	printf("unsigned short a = %hu\n", a2);
	printf("unsigned int b = %u\n", b2);
	printf("unsigned long c = %lu\n", c2);
	printf("unsigned long long d = %llu\n", d2);

	return 0;
}
```



### 2.5.4有符号数和无符号数区别

##### 1) 有符号数

有符号数是最高位为符号位，0代表正数，1代表负数。

![image-20190924143831395](assets/image-20190924143831395.png)

```c
#include <stdio.h>

int main()
{
	signed int a = -1089474374; //定义有符号整型变量a
	printf("%X\n", a); //结果为 BF0FF0BA

	//B       F      0        F       F     0        B	      A
	//1011 1111 0000 1111 1111 0000 1011 1010

	return 0;
}
```

##### 2) 无符号数

无符号数最高位不是符号位，而就是数的一部分，无符号数不可能是负数。

![image-20190924143858993](assets/image-20190924143858993.png)

```c
#include <stdio.h>

int main()
{
	unsigned int a = 3236958022; //定义无符号整型变量a
	printf("%X\n", a); //结果为 C0F00F46

	return 0;
}
```

当我们写程序要处理一个不可能出现负值的时候，一般用无符号数，这样可以增大数的表达最大值。

##### 3) 有符号和无符号整型取值范围

| **数据类型**   | **占用空间** | **取值范围**                             |
| -------------- | ------------ | ---------------------------------------- |
| short          | 2字节        | -32768 到32767 (-215~ 215-1)             |
| int            | 4字节        | -2147483648 到 2147483647 (-231 ~ 231-1) |
| long           | 4字节        | -2147483648 到 2147483647 (-231 ~ 231-1) |
| unsigned short | 2字节        | 0 到 65535 (0 ~ 216-1)                   |
| unsigned int   | 4字节        | 0 到 4294967295 (0 ~ 232-1)              |
| unsigned long  | 4字节        | 0 到 4294967295 (0 ~ 232-1)              |



## 2.6字符型：char

### 2.6.1字符变量的定义和输出

字符型变量用于存储一个单一字符，在 C 语言中用 char 表示，其中每个字符变量都会占用 1 个字节。在给字符型变量赋值时，需要用一对英文半角格式的单引号(' ')把字符括起来。

字符变量实际上并不是把该字符本身放到变量的内存单元中去，而是将该字符对应的 ASCII 编码放到变量的存储单元中。char的本质就是一个1字节大小的整型。

```c
#include <stdio.h>

int main()
{
	char ch = 'a';
	printf("sizeof(ch) = %u\n", sizeof(ch));

	printf("ch[%%c] = %c\n", ch); //打印字符
	printf("ch[%%d] = %d\n", ch); //打印‘a’ ASCII的值

	char A = 'A';
	char a = 'a';
	printf("a = %d\n", a);		//97
	printf("A = %d\n", A);	//65

	printf("A = %c\n", 'a' - 32); //小写a转大写A
	printf("a = %c\n", 'A' + 32); //大写A转小写a

	ch = ' ';
	printf("空字符：%d\n", ch); //空字符ASCII的值为32
	printf("A = %c\n", 'a' - ' '); //小写a转大写A
	printf("a = %c\n", 'A' + ' '); //大写A转小写a

	return 0;
}
```

